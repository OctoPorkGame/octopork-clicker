<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OctoPork Clicker</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
    #game { position: relative; width: 800px; height: 600px; margin: 20px auto; overflow: hidden; }
    #octopork { cursor: pointer; width: 300px; position: absolute; left: 250px; top: 150px; }
    #waste { position: absolute; top: 50px; left: 350px; font-size: 18px; color: #ff4500; transition: opacity 0.5s; }
    #saved, #total, #players, #message { font-size: 20px; margin: 10px; }
    canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
    .confetti { position: absolute; width: 10px; height: 10px; }
    /* Leaderboard styling */
    #leaderboard-section { margin-top: 20px; width: 800px; margin-left: auto; margin-right: auto; }
    #leaderboard-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    #leaderboard-table th, #leaderboard-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    #leaderboard-table th { background-color: #f2f2f2; }
    #leaderboard-table tr:nth-child(even) { background-color: #f9f9f9; }
    #leaderboard-table tr:hover { background-color: #e6e6e6; }
    /* Name prompt styling */
    #name-prompt { 
      position: fixed; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      background: white; 
      padding: 20px; 
      border: 2px solid #333; 
      border-radius: 10px; 
      box-shadow: 0 0 10px rgba(0,0,0,0.3); 
      z-index: 1000; 
    }
    #name-prompt input { 
      padding: 5px; 
      margin: 10px; 
      font-size: 16px; 
    }
    #name-prompt button { 
      padding: 5px 10px; 
      background: #4CAF50; 
      color: white; 
      border: none; 
      border-radius: 5px; 
      cursor: pointer; 
    }
    #name-prompt button:hover { 
      background: #45a049; 
    }
  </style>
</head>
<body>
  <h1>OctoPork Clicker</h1>
  <div id="game">
    <img id="octopork" src="octopork-image.png" alt="OctoPork">
    <div id="waste"></div>
    <canvas id="coins" width="800" height="600"></canvas>
  </div>
  <div id="saved">$PORK Saved: $0</div>
  <div id="total">Total $PORK Saved: $0</div>
  <div id="players">Players Shredding Waste: 0</div>
  <div id="message">Uncover $36T in waste—then we might launch $PORK to the moon!</div>

  <!-- Leaderboard Section -->
  <div id="leaderboard-section">
    <h2>Leaderboard - Top 10 Shredders</h2>
    <table id="leaderboard-table">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Player Name</th>
          <th>Total $PORK Saved</th>
        </tr>
      </thead>
      <tbody id="leaderboard-body"></tbody>
    </table>
  </div>

  <!-- Name Prompt Modal -->
  <div id="name-prompt" style="display: none;">
    <h3>Welcome to OctoPork Clicker!</h3>
    <p>Please enter your player name:</p>
    <input type="text" id="player-name-input" maxlength="20" placeholder="Your name">
    <br>
    <button onclick="submitPlayerName()">Submit</button>
  </div>

  <audio id="cha-ching" src="cha-ching.mp3"></audio>
  <audio id="shredder" src="shredder.mp3"></audio>

  <script>
    const wasteItems = [
      { text: "$10M Golden Toilet Throne", amount: 10000000 },
      { text: "$2M Diamond Stapler Study", amount: 2000000 },
      { text: "$500K Pork-Filled Briefcase", amount: 500000 },
      { text: "$1B Kitchen Sink Subsidy", amount: 1000000000 },
      { text: "$750K Senator Selfie Statues", amount: 750000 },
      { text: "$25M Pentagon Coffee Fund", amount: 25000000 },
      { text: "$3.5M Jet Joyride", amount: 3500000 },
      { text: "$100M Bridge to Nowhere", amount: 100000000 },
      { text: "$50K Gold Paperclips", amount: 50000 },
      { text: "$6B Typo Cover-Up", amount: 6000000000 }
    ];

    let saved = parseInt(localStorage.getItem('porkSaved')) || 0;
    let playerCount = 1;
    let totalSaved = 0;
    const TARGET = 36000000000000; // $36T

    const octopork = document.getElementById('octopork');
    const wasteDiv = document.getElementById('waste');
    const savedDiv = document.getElementById('saved');
    const totalDiv = document.getElementById('total');
    const playersDiv = document.getElementById('players');
    const messageDiv = document.getElementById('message');
    const canvas = document.getElementById('coins');
    const ctx = canvas.getContext('2d');
    const chaChing = document.getElementById('cha-ching');
    const shredder = document.getElementById('shredder');

    savedDiv.textContent = `$PORK Saved: $${saved.toLocaleString()}`;
    totalDiv.textContent = `Total $PORK Saved: $${totalSaved.toLocaleString()}`;
    playersDiv.textContent = `Players Shredding Waste: ${playerCount.toLocaleString()}`;

    // Generate or retrieve playerId
    let playerId = localStorage.getItem('playerId');
    if (!playerId || !/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(playerId)) {
      playerId = crypto.randomUUID();
      localStorage.setItem('playerId', playerId);
      console.log('Generated new playerId:', playerId);
    } else {
      console.log('Using existing playerId:', playerId);
    }

    // Check and prompt for player name
    let playerName = localStorage.getItem('playerName');
    async function checkPlayerName() {
      if (playerName) {
        console.log('Player name already set:', playerName);
        return;
      }

      if (window.location.protocol === 'file:') {
        console.log('Running locally - skipping name check and mocking name');
        playerName = 'LocalPlayer';
        localStorage.setItem('playerName', playerName);
        return;
      }

      try {
        const response = await fetch('/.netlify/functions/get-player-name', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ playerId })
        });
        const data = await response.json();
        if (data.name) {
          playerName = data.name;
          localStorage.setItem('playerName', playerName);
          console.log('Player name retrieved from Firebase:', playerName);
        } else {
          showNamePrompt();
        }
      } catch (error) {
        console.error('Failed to check player name:', error.message);
        showNamePrompt();
      }
    }

    function showNamePrompt() {
      const namePrompt = document.getElementById('name-prompt');
      namePrompt.style.display = 'block';
      document.getElementById('player-name-input').focus();
    }

    async function submitPlayerName() {
      const nameInput = document.getElementById('player-name-input').value.trim();
      if (!nameInput || nameInput.length < 3 || nameInput.length > 20) {
        alert('Please enter a name between 3 and 20 characters.');
        return;
      }

      playerName = nameInput;
      localStorage.setItem('playerName', playerName);
      document.getElementById('name-prompt').style.display = 'none';

      try {
        const response = await fetch('/.netlify/functions/set-player-name', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ playerId, name: playerName })
        });
        const data = await response.json();
        console.log('Set player name response:', data);
      } catch (error) {
        console.error('Failed to set player name:', error.message);
      }
    }

    // Allow Enter key to submit name
    document.getElementById('player-name-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') submitPlayerName();
    });

    async function updateStats() {
      console.log('Attempting to fetch stats...');
      if (window.location.protocol === 'file:') {
        console.log('Running locally - skipping fetch and mocking data');
      } else {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          const res = await fetch('/.netlify/functions/stats', {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          console.log('Fetch response status:', res.status, 'OK:', res.ok, 'Headers:', [...res.headers]);
          if (!res.ok) throw new Error(`HTTP error! Status: ${res.status}`);
          const text = await res.text();
          console.log('Raw response text:', text);
          const data = text ? JSON.parse(text) : { total: 0, players: 0 };
          console.log('Parsed data:', data);
          totalSaved = data.total || 0;
          playerCount = data.players || 0;
        } catch (err) {
          console.error('Stats fetch failed:', err.message);
        }
      }
      totalDiv.textContent = `Total $PORK Saved: $${totalSaved.toLocaleString()}`;
      playersDiv.textContent = `Players Shredding Waste: ${playerCount.toLocaleString()}`;
      if (totalSaved >= TARGET && playerCount >= 10000) {
        messageDiv.textContent = '$36T uncovered! Time to launch $PORK—stay tuned!';
      }
    }

    async function updateLeaderboard() {
      console.log('Attempting to fetch leaderboard...');
      if (window.location.protocol === 'file:') {
        console.log('Running locally - skipping leaderboard fetch and mocking data');
        return;
      }
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        const response = await fetch('/.netlify/functions/leaderboard', {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        console.log('Leaderboard fetch response status:', response.status, 'OK:', response.ok);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

        const data = await response.json();
        console.log('Leaderboard response:', data);
        const leaderboardBody = document.getElementById('leaderboard-body');
        leaderboardBody.innerHTML = '';

        data.leaderboard.forEach((entry, index) => {
          const row = document.createElement('tr');
          // Highlight the current player's row
          if (entry.playerId === playerId) {
            row.style.backgroundColor = '#d4edda'; // Light green for current player
          }
          row.innerHTML = `
            <td>${index + 1}</td>
            <td>${entry.name || 'Anonymous'}</td>
            <td>$${entry.total.toLocaleString()}</td>
          `;
          leaderboardBody.appendChild(row);
        });
      } catch (error) {
        console.error('Leaderboard fetch failed:', error.message);
      }
    }

    async function updateGameData() {
      await updateStats();
      await updateLeaderboard();
    }

    // Initialize game data and check player name
    async function initializeGame() {
      await checkPlayerName();
      await updateGameData();
    }

    initializeGame();
    setInterval(updateGameData, 5000);

    octopork.onclick = async () => {
      const item = wasteItems[Math.floor(Math.random() * wasteItems.length)];
      saved += item.amount;
      localStorage.setItem('porkSaved', saved);
      wasteDiv.textContent = item.text;
      wasteDiv.style.opacity = 1;
      savedDiv.textContent = `$PORK Saved: $${saved.toLocaleString()}`;

      chaChing.play().catch(() => {});
      shredder.play().catch(() => {});

      explodeWaste();
      dropCoin();

      console.log('Sending click with amount:', item.amount, 'playerId:', playerId);
      fetch('/.netlify/functions/click', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ amount: item.amount, playerId })
      })
        .then(res => {
          console.log('Click fetch response status:', res.status);
          return res.json();
        })
        .then(data => console.log('Click response:', data))
        .catch(err => console.error('Click report failed:', err.message));

      if (window.location.protocol === 'file:') {
        console.log('Running locally - mocking updateStats');
        totalSaved += item.amount;
        playersDiv.textContent = `Players Shredding Waste: ${playerCount.toLocaleString()}`;
        totalDiv.textContent = `Total $PORK Saved: $${totalSaved.toLocaleString()}`;
        savedDiv.textContent = `$PORK Saved: $${saved.toLocaleString()}`;
      } else {
        await updateGameData();
      }
    };

    function explodeWaste() {
      const wasteRect = wasteDiv.getBoundingClientRect();
      const gameRect = document.getElementById('game').getBoundingClientRect();
      const startX = wasteRect.left - gameRect.left + wasteRect.width / 2;
      const startY = wasteRect.top - gameRect.top + wasteRect.height / 2;

      for (let i = 0; i < 20; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
        confetti.style.left = `${startX}px`;
        confetti.style.top = `${startY}px`;
        document.getElementById('game').appendChild(confetti);

        const angle = Math.random() * 2 * Math.PI;
        const speed = Math.random() * 5 + 2;
        let vx = Math.cos(angle) * speed;
        let vy = Math.sin(angle) * speed;

        const animate = () => {
          const x = parseFloat(confetti.style.left) + vx;
          const y = parseFloat(confetti.style.top) + vy;
          vy += 0.1;
          confetti.style.left = `${x}px`;
          confetti.style.top = `${y}px`;

          if (y < 600) requestAnimationFrame(animate);
          else {
            confetti.remove();
            wasteDiv.style.opacity = 0;
          }
        };
        animate();
      }
    }

    function dropCoin() {
      const coin = { x: Math.random() * 700 + 50, y: 0, vy: 5, opacity: 1 };
      const animate = () => {
        ctx.clearRect(0, 0, 800, 600);
        ctx.font = '20px Arial';
        ctx.fillStyle = `rgba(255, 215, 0, ${coin.opacity})`;
        ctx.fillText('$', coin.x, coin.y);
        coin.y += coin.vy;
        coin.vy += 0.1;
        coin.opacity -= 0.02;
        if (coin.y < 600 && coin.opacity > 0) requestAnimationFrame(animate);
      };
      animate();
    }
  </script>
</body>
</html>
